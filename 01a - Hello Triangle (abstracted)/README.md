# 01a - Hello Triangle (abstracted)
This demo is functionally identical to the previous Hello Triangle demo. The main difference is the code organization in this one. With this version of the project, I aim to split up and organize the project. I'll also be implementing the frame loop solution discussed in the [Frames In Flight](https://docs.vulkan.org/tutorial/latest/03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html) section of the Khronos Vulkan tutorial.

The goal of abstracting the code out into different namespaces and classes is not just to organize the code better. Although the list-of-functions approach taken in the first iteration of this demo resulted in a huge single source file that was tough to navigate, the functions themselves created a simple, linear process that works well enough for this demo. I would like to use this abstraction as a jumping-off point, not just to improve my understanding and continue following the Vulkan tutorials provided but also to pursue my own little demos and projects soon afterward.

Unfortunately, I'm not at a great level of understanding about which parts of the Vulkan rendering process need which levels of abstraction. I don't know which parts of the process I'll be tinkering and interfacing with more than others. I'm working with a sample size of 1, and that sample is an incredibly simple one. But, based on everything I've learned so far, I've made an educated guess. I'll probably make more improvements to it and add to this abstraction in future iterations of this demo, as I improve my understanding of this framework, and my way of interfacing with it.

With all of that mind, here's what I came up with:

- ```main.cpp``` - The main source file, being the entry point of the program, still handles overall initialization and deletion of Vulkan resources, but the individual processes of initialization/deletion have been delegated to different classes and namespaces. This source file also contains the draw loop, so ultimately handles all drawing commands, including recording the command buffer. Finally, this file also ultimately handles shader module creation, but again, part of the general initalization process has been delegated to a different file. This is the work which someone using my framework would need to do in order to reimplement the demo.

- ```vksetup.cpp/.h``` - Handles setting up the ```VkDevice``` handle used to create, access, and use most other Vulkan resources. The steps to intialize a Vulkan device include creating a ```VkInstance```, selecting a physical GPU and whatever extensions we're using, and enabling validation layers if applicable. Some generic initialization functions have been delegated to this file, such as some helper functions to fast-track the creation of ```VkSemaphore```s and ```VkFence```s. This function also contains other functions to aid in setting up other Vulkan resources, like ```find_physical_device_queue_families``` and ```query_swap_chain_support```.

- ```swapchain.cpp/.h``` - Contains the ```Swapchain``` class, which has the ```VkSwapchainKHR``` handle as well as the format, extent, images, image views, and framebuffers which it uses. Since I don't plan on messing with the swap chain that much, the creation of the swap chain is very opaque for now, though I may need to "open up" how image views and framebuffers specifically are created in the near future.

- ```renderpass.cpp/.h``` - Unlike swap chains, render passes are much more of a wrapper over the existing Vulkan specification. The file contains a generic ```RenderPass``` class which contains a list of attachments, subpasses, and dependencies, which can be added to the render pass with the associated ```add_...``` functions, and then "compiled" with ```compile_render_pass```, which handles the ```VkRenderPassCreateInfo``` stuff. Since this is still meant to make things shorter for a little while, there is also a ```DefaultColorRenderPass``` class which extends the former, and implements a series of "default" (built-in) color attachments, subpasses, and subpass dependencies.

- ```pipeline.cpp/.h``` - Very similar to ```renderpass.cpp/.h```, except applied to ```VkPipeline```s instead of ```VkRenderPass```es. Fixed function structs can be set individually on a ```Pipeline``` class object, or there's a ```DefaultColorPipeline``` which implements a bunch of "default" fixed functions generally applicable to a simple color attachment with no semi-transparency (blending).

- ```vkcommands.cpp/.h``` - Despite the name, currently only contains a helper class for a ```VkCommandPool```, the ```CommandPool``` class, which allows the allocation of a ```VkCommandBuffer``` from it. I may add some helper functions for drawing to this file in the future, but my understanding of drawing commands with Vulkan is currently limited to just a single per-vertex triangle, so I'm holding off on that for now.

I understand that finding "shortcuts" goes against the philosophy of the Vulkan API, and so my goal here was to try and "ease" the amount of code required to get something done while still keeping things open to tinker with, and without just... reinventing OpenGL.

As noted earlier, this updated version of the demo also contains a fix to an issue with the draw loop.

The way the tutorial had set things up, we waited for all operations on the frame to completely cease before beginning operations on the next. While this is a fine way to do things, it kind of defeats the point of having a swap chain to begin with. The point of a swap chain is to present the latest available image *while* another one is being rendered to.

In order to fix this, we basically need to use multiple semaphores and fences per frame in the swap chain. That way, the only time the draw loop would need to wait is when it tries to retrieve and perform operations on the image that is *currently on the screen*, rather than the one of the others in the swap chain.

In my case, I just assume that there are two images in the swap chain, and create two semaphores/fences for each applicable part of the process, alternating between one and the other each frame, just as the tutorial does.